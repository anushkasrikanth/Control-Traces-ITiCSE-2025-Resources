#+title:  next control transfer function

Blocks and Statements are identified as intervals of
locations.  A program is a map from locations to
instructions (except the last location)
#+begin_example
B=[f..l]
S=[f..l]
I=[i..i]
first: B+S+P -> L
last: B+S+P -> L
#+end_example

* Statement Types
#+begin_example
whileS?: S -> Bool
ifS?: S -> Bool
defS?: S -> Bool
atomicS?: S -> Bool
breakS?: S -> Bool
contS?: S -> Bool
passS?: S -> Bool
eassignS?: S -> Bool
retS?: S -> Bool
fnassignS?: S -> Bool
top?: B -> Bool
#+end_example
* Components
#+begin_example
pblk: P -> B
iftest: ifS? -> ifI?
then: ifS? -> B
else: ifS? -> B
fhead: defS? -> defI?
fbody: defS? -> B
wtest: whileS? -> whileI?
wbody: whileS? -> B
stmts: B -> List[S]
called_fn_name: fnassignS? -> Id // returns the id of the called
get_def: Id -> defS? // returns the function
                     // definition statement
                     // for the fn id.

defname: defI? -> Id
defformals: defI? -> seq[Id]
wexp: whileI? -> E?
ifexp: ifI? -> E?
#+end_example

* Parent

 - Parent of a block is the statement enclosing it and
   undefined if the block is top-level.

 - Parent of a statement is the enclosing block along with
   the index of that statement in the block.

 - Parent of an instruction is the statement the instruction
   is part of.  If the instruction is a statement itself,
   then it is its own parent.
  
#+begin_example
p: B -> S  (except the top level block)
p: S -> B x Nat
p: I -> S //
#+end_example

* Encl_pred
#+begin_example
encl_pred: S->bool -> [S -> S]
encl_pred(pred?)(s) = 
  let (b,_) = p(s):
    if top?(b):
        undef
    let g = p(b): // fails if b is top?
      if pred?(g):
        g
      else:
         encl_pred(pred?)(g)
#+end_example
* Encl_while
#+begin_example
encl_while: S -> S
encl_while = encl_pred(whileS?)
#+end_example
* next
#+begin_example
next: S -> S

next(s:contS?) = encl_while(s)
next(s:breakS?) = next(encl_while(s))
next(s:retS?) = undef

next(s) =
  let (b,i) = p(s)
     if i = len(b)-1:
        if top?(b): then undef
        else:
          next(p(b))
     else:
         stmts(b, i+1)

#+end_example
* true and false
#+begin_example
true: S -> S
true(s:ifS?) =
   then(s)
   
true(s:whileS?) =
   wbody(s)

true(s) =
   undef

false: S -> S
false(s:ifS?) =
  else(s)

false(s:whileS?) =
  next(s)

false(s) =
  undef
#+end_example

* call
#+begin_example
call: S -> S 
call(s:fnassignS?) =
    stmts(fbody(get_def(called_fn_name(s))))[0]
call(s) = undefine // otherwise
#+end_example
* Encl_def
#+begin_example
encl_def: S -> S
encl_def = encl_pred(defS?)
#+end_example
* ret
#+begin_example
ret: S -> set[S]
ret(s:retS?) =
   id = defname(fhead(encl_def(s)))
   {next(s)| s: S AND fnassign?(s) AND called_fn_name(s) = id}
#+end_example

* Statement transfer functions
#+begin_example
stf? = {next, true, false, call, ret}
#+end_example

* lctf
#+begin_example
ctf: stf? -> L -> L
ctf(stf)(i) = first(stf(p(P(i))))
err: L -> L
err(i) = last(P)
#+end_example

